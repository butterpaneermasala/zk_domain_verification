# ZK package (Groth16, circom)

This package contains a minimal circuit to prove knowledge of a 64-byte secret L such that SHA-256(L) = H. The 256-bit digest H is exposed as two 128-bit public limbs (h_hi, h_lo) in big-endian order.

## Layout
- circuits/commit64_sha256.circom — main circuit (imports circomlib sha256)
- build/ — output artifacts (r1cs, wasm, zkey, verification_key.json, proof.json, public.json)
- scripts/ — helper scripts to prove and copy the VK into the Next.js app

## Prereqs
- circom v2 installed on your PATH
- snarkjs (npm) installed via this package
- circomlib circuits available at `circomlib/` folder here (git submodule recommended)

Add circomlib as a submodule:
```bash
cd packages/zk
git submodule add https://github.com/iden3/circomlib.git circomlib
```

## Build steps
```bash
# From packages/zk
# 1) Powers of tau (ptau)
yarn setup:ptau

# 2) Compile circom
# -l flags include circomlib circuits and sha256 folder
yarn compile

# 3) Groth16 setup and export verification key
yarn setup:zkey

# 4) Prove with a sample input
# Edit build/input.json with fields:
# {
#   "in": [64 bytes 0..255],
#   "h_hi": "<decimal string>",
#   "h_lo": "<decimal string>"
# }
# (h_hi,h_lo) are the big-endian limbs of sha256(in)
yarn prove

# 5) Verify the proof
yarn verify

# 6) Copy verification key into the Next.js API folder
yarn copy:vk
```

## Using from the Next.js API
- Set `ENFORCE_ZK=true` and ensure `packages/nextjs/services/zk/verification_key.json` exists
- POST `/api/prove-secret` with `{ proof, publicSignals }` generated by `snarkjs.groth16.fullProve`
- The API verifies the proof and returns `{ ok: true, hHex }` (reconstructed from publicSignals if not provided)

Note: The server doesn’t recompute SHA-256 when enforcement is on; it trusts the proof. Keep the same limb encoding (big-endian halves) between client and circuit. If you use a different layout, adjust the API route accordingly.
